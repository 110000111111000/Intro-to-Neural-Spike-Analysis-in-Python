---
title: "Relating Neural Firing to Stimuli"
engine: Jupyter
format: ipynb
filters:
    - assign
number-sections: true
number-depth: 2
---

## Preparation

Import the modules required for this session
```{python}
import pandas as pd
import numpy as np
from matplotlib import pyplot as plt
import seaborn as sns
from scipy.stats import wilcoxon
%matplotlib inline
```


Download the data required for this session
```{python}
# | eval: false
import requests

urls = [
    "https://uni-bonn.sciebo.de/s/G64EkHoQkeZeoLm",
    "https://uni-bonn.sciebo.de/s/mLMkb2TwbNx3Yg6",
]
fnames = ["flash_stimuli.parquet", "flash_spikes.parquet"]

for url, fname in zip(urls, fnames):
    response = requests.get(f"{url}/download")
    print("Downloading Data ...")
    with open(fname, "wb") as file:
        file.write(response.content)
    print("Done!")
```


## Referencing Spike Times to Stimulus Presentations

| Code | Description |
| --- | --- |
| `df = pd.read_parquet(mydata.paquet)` | Read the file `"mydata.parquet"` into a data frame |
| `pd.merge_asof(left, right, left_on, right_on)` | Merge data frames `left` and `right` based on the columns `left_on` and `right_on` |
| `df["newcol"] = values` | Add a new column named `"newcol"` to `df` and assign it the `values` |
| `df[df.col1<1]` | Get all rows of `df` where the value of `"col1"` is smaller than 1 |
| `sns.histplot(df, x="col1", hue="col2")` | Plot a histogram of the values in `"col1"` and add a `hue` for the categories in `"col2"` |
| `plt.axvline(x, ymin, ymax)` | Add a vertical line at `x` that goes from `ymin` to `ymax` |
| `plt.xlim(xmin, xmax)` | Limit the x-axis to the range between `xmin` and `xmax` |

---

:::{#exr-}
Load the data stored in the files `"flash_spikes.parquet"` and `"flash_stimuli.parquet"` into data frames and assign them to variables called `spikes` and `stimuli`.
:::
:::{.sol}
```{python}
spikes = pd.read_parquet("flash_spikes.parquet")
stimuli = pd.read_parquet("flash_stimuli.parquet")
```
:::

:::{#exm-}
Use `pd.merge_asof()` to merge the `spikes` and `stimuli` based on the `"spike_time"` and `"start_time"`. In the resulting `df`, each spike is paired with the last stimulus that was presented before that spike.
:::
```{python}
df = pd.merge_asof(spikes, stimuli, left_on="spike_time", right_on="start_time")
df
```

:::{#exr-}
Subtract the stimulus `.start_time` column from the `.spike_time` column to get the spike times relative to stimulus onset. Then, print the smallest spike time in `df`.
:::
:::{.sol}
```{python}
df.spike_time = df.spike_time - df.start_time
df.spike_time.min()
```
:::

:::{#exr-}
The smallest spike time should be very close to 0. However, we would like our analysis time window to include spikes that happen before the stimulus as well. Add a new column to `stimuli` called `"analysis_window_start"` that is equal to the stimulus `"start_time"` minus `0.5` seconds. Print the `stimuli` to make sure the new column was created.
:::
:::{.sol}
```{python}
stimuli["analysis_window_start"] = stimuli["start_time"] - 0.5
stimuli
```
:::

:::{#exr-}
Use `pd.merge_asof()` with `right_on="analysis_window_start"` to match each spike with the analysis window that started before it.
:::
:::{.sol}
```{python}
df = pd.merge_asof(
    spikes, stimuli, left_on="spike_time", right_on="analysis_window_start"
)
df
```
:::

:::{#exr-}
Subtract the stimulus `.start_time` column from the `.spike_time` column to get the spike times relative to stimulus onset. Then, print the smallest spike time in `df` this value should be very close to `-0.5`.
:::
:::{.sol}
```{python}
df.spike_time = df.spike_time - df.start_time
df.spike_time.min()
```
:::

:::{#exr-}
Remove all the the rows in `df` where the `"spike_time"` relative to stimulus onset is greater than `1` second and print the maximum spike time.
:::
:::{.sol}
```{python}
df = df[df.spike_time <= 1]
df.spike_time.max()
```
:::

:::{#exr-}
Use `sns.histplot` to create a histogram of spike times relative to stimulus onset.
:::
:::{.sol}
```{python}
sns.histplot(df, x="spike_time")
```
:::

:::{#exr-}
Use `sns.histplot` to create a histogram of spike times and use `plt.axvline()` to add vertical lines that mark the stimulus onset at `0` seconds and the offset at `0.25` seconds (HINT: try using `color="black"` and `linestyle="--"` to make them look nice). Can you see the relationship between the spiking and stimuli?
:::
:::{.sol}
```{python}
sns.histplot(df, x="spike_time")
plt.axvline(x=0, ymin=0, ymax=1, color="black", linestyle='--')
plt.axvline(x=0.25, ymin=0, ymax=1, color="black", linestyle='--')
```
:::

:::{#exr-}
Add a `hue` to the histogram that encodes the `"brain_area"`.
:::
:::{.sol}
```{python}
sns.histplot(df, x="spike_time", hue="brain_area")
```
:::

:::{#exr-}
Increate the number of `bins` in the histogram to improve the temporal resolution and limit the x-axis to the first `0.15` second after stimulus onset. Can you see which brain area responds first?
:::
:::{.sol}
```{python}
sns.histplot(df, x="spike_time", hue="brain_area", bins=300)
plt.xlim(0, 0.15)
```
:::

## Comparing Neural Spiking to a Baseline

| Code | Description |
| --- | --- |
| `np.arange(start, stop, stepsize)` | Create an array of evenly spaced elements between `start` and `stop` with the given `stepsize` |
| `df.groupby(["col1", "col2"]).col3.mean()` | Group the data by columns `"col1"` and `"col2"` and calulcate the `.mean()` of `"col3"` for each grouping |
| `df.groupby(["col1", "col2"]).col3.apply(fun)` | Group the data by columns `"col1"` and `"col2"` and `.apply()` the function `fun` to `"col3"` for each grouping |
| `df = df.reset_index()` | reset the index of `df` and store the old index in a new column |
| `df = df.reset_index(drop=True)` | reset the index of `df` and drop the old index |
| `df.columns = ["new1", "new2"]` | Rename the columns of `df` to `"new1"` and `"new2"` |
| `df.explode("col1")` | `.explode()` the colum `"col1"` which contains lists so that a new row is created for every element |
| `df.explode(["col1", "col2"])` | `.explode()` the colums `"col1"` and `"col2"` so that a new row is created for every element |
| `df1.col1.map(df2)` | Map `df2` to `df1` based on the column `col1` |
| `sns.lineplot(df, x="col1", y="col2", hue="col3")` | Plot the values in `"col1"` against `"col2"` and add a `hue` based on `"col3"` |
| `sns.lineplot(df, x="col1", y="col2", units="col3", estimator=None)` | Plot the values in `"col1"` against `"col2"` separately for all `units` in `"col3"` |

:::{#exr-}
Use `np.arange` to create an array of evenly spaced bins between `0` and `1` seconds that are `0.005` seconds wide. Print the number of bins in the array. 
:::
:::{.sol}
```{python}
bins = np.arange(0, 1, 0.01)
bins.shape
```
:::

:::{#exr-}
Use `np.arange` to create an array of evenly spaced bins between `0` and `0.5` seconds that are `0.01` seconds wide. Print the number of bins in the array. 
:::
:::{.sol}
```{python}
bins = np.arange(-0.5, 1, 0.005)
bins.shape
```
:::

:::{#exm-psth}
Use `.groupby()` to group the `df` by `"unit_id"` and `"brain_area"` and `.apply()` the `np.histogram` function with the previously created `bins` to the spike times. Write the result to a new variable called `psths` and select the first element in each row (which contains the spike counts).
:::
```{python}
psths = df.groupby(["unit_id", "brain_area"]).spike_time.apply(np.histogram, bins=bins)
psths = psths.str[0]
psths
```

:::{#exr-}
Use the `.reset_index()` method to transform the `psths` to a data frame and label the `.columns` as `"unit_id"`, `"brain_area"` and `"spike_count"`. Print the resulting data frame.
:::
:::{.sol}
```{python}
psths = psths.reset_index()
psths.columns = ["unit_id", "brain_area", "spike_count"]
psths
```
:::

:::{#exm-}
Compute the `bin_centers` and store them in new column called `"time"`.
:::
```{python}
bin_centers = (bins[:-1] + bins[1:]) / 2
psths["time"] = [bin_centers for i in range(len(psths))]
```

:::{#exr-}
Use the `.explode()` method to extend the columns `["spike_count", "time"]`. Overwrite the `psths` data frame with the returned value and print it.
:::
:::{.sol}
```{python}
psths = psths.explode(["spike_count", "time"]).reset_index(drop=True)
psths
```
:::

:::{#exr-}
Create an `sns.lineplot` of the average `"spike_count"` across `"time"`.
:::
:::{.sol}
```{python}
sns.lineplot(psths, x="time", y="spike_count")
```
:::

:::{#exr-}
Compute the baseline firing rate of each unit by selecting the rows of `psths` where `psths.time<0`, grouping them by `"unit_id"` and calculating the mean spike count.
:::
:::{.sol}
```{python}
baselines = psths[psths.time<0].groupby("unit_id").spike_count.mean()
baselines
```
:::

:::{#exr-}
Use `.map()` to map the baselines to the `psths` based on `"unit_id"` and write the result to a new column in `psths` called `"baseline"`.
:::
:::{.sol}
```{python}
psths["baseline"] = psths.unit_id.map(baselines)
```
:::

:::{#exr-}
Subtract the `"baseline"` from the `"spike_count"` and write the result to a new column called `"baselined_spike_count"`.
:::
:::{.sol}
```{python}
psths["baselined_spike_count"] = psths.spike_count - psths.baseline
```
:::

:::{#exr-}
Create an `sns.lineplot` of the `"baselined_spike_count"` across `"time"`.
:::
:::{.sol}
```{python}
sns.lineplot(psths, x="time", y="baselined_spike_count")
```
:::


:::{#exr-}
Add a `hue` to the lineplot that encodes the `"brain_area"` and limit the x-axis to the range from `0` to `0.5` seconds.
:::
:::{.sol}
```{python}
sns.lineplot(psths, x="time", y="baselined_spike_count", hue="brain_area")
plt.xlim(0, 0.5)
```
:::

:::{#exr-}
Set `estimator=None` and `units="unit_id"` to plot every unit individually.
:::
```{python}
sns.lineplot(psths, x="time", y="baselined_spike_count", hue="brain_area", estimator=None, units="unit_id")
plt.xlim(0, 0.5)
```


## Identifying Responsive Units


:::{#exr-}
Compute the spike count relative to the baseline by subtracting the `"baseline"` from the `"spike_count"` and dividing the result by the `"baseline"`.
:::
:::{.sol}
```{python}
psths["relative_spiking"] = (psths.spike_count - psths.baseline) / psths.baseline
psths
```
:::

:::{#exr-line}
Create a `sns.lineplot` with `estimator=None` and `units="unit_id"` to plot the `"relative_spiking"` for every unit. Limit the x-axis to the range between `0` and `0.5` seconds.
:::
:::{.sol}
```{python}
sns.lineplot(
    psths,
    x="time",
    y="relative_spiking",
    hue="brain_area",
    units="unit_id",
    estimator=None,
)
plt.xlim(0, 0.5)
```
:::

:::{#exr-}
Compute the spike count relative to the baseline by subtracting the `"baseline"` from the `"spike_count"` and dividing the result by the `"baseline"` + the parameter `epsilon` defined below. This avoids distorting the responses of neurons with baselines close to 0. Overwrite the `"relative_spiking"` columns with the new values
:::
```{python}
epsilon = 0.2
```
:::{.sol}
```{python}
psths["relative_spiking"] = (psths.spike_count - psths.baseline) / (
    psths.baseline + epsilon
)
psths
```
:::

:::{#exr-}
Re-create the plot from @exr-line with the new `"relative_spiking"` values.
:::
```{python}
sns.lineplot(
    psths,
    x="time",
    y="relative_spiking",
    hue="brain_area",
    units="unit_id",
    estimator=None,
)
plt.xlim(0, 0.5)
```

:::{#exr-}
Increase the value of `epsilion`, then re-compute the the values of the `"relative_spiking"` and plot them to see the effect of the regularization parameter.
:::
:::{.sol}
```{python}
epsilon = 1
psths["relative_spiking"] = (psths.spike_count - psths.baseline) / (
    psths.baseline + epsilon
)
psths
sns.lineplot(
    psths,
    x="time",
    y="relative_spiking",
    hue="brain_area",
    units="unit_id",
    estimator=None,
)
plt.xlim(0, 0.5)
```
:::

:::{#exr-}
Group the PSTHs by the `"unit_id"` and compute the `.max()` of the `"relative_spiking"` for each unit. Plot them in a histogram and draw a `plt.axvline` at the `threshold`.
:::
```{python}
threshold = 1.5
```
```{python}
sns.histplot(psths.groupby("unit_id").relative_spiking.max())
plt.axvline(x=threshold, ymin=0, ymax=1, color="red")
```

:::{#exm-resp}
Select the PSTHs of all units where the maximum `"relative_spiking"` exceeds the threshold and assign them to a new data frame called `psths_responsive`.
:::
```{python}
is_responsive = psths.groupby("unit_id").relative_spiking.max() > threshold
responsive_units = is_responsive[is_responsive].index
psths_responsive = psths[psths.unit_id.isin(responsive_units)]
```

:::{#exr-}
Create a `sns.lineplot` of the `"baselined_spike_count"` across `"time"` for the responsive units and add a `hue` to encode the `"brain_area"`.
:::
:::{.sol}
```{python}
sns.lineplot(psths_responsive, x="time", y="baselined_spike_count", hue="brain_area")
plt.xlim(0, 0.5)
```
:::

:::{#exr-}
Increase the `threshold` and re-compute the `psths_responsive` as shown in @exm-resp. Then re-create the plot of the responsive unit's`"baselined_spike_count"` to see the effect of the increased threshold.
:::

## Estimating peak latency

| Code | Description |
| --- | --- |
| `df.groupby("col1").col2.idxmax()` | Group `df` by `"col1"` and get the index of the maximum value in `"col2"` for each grouping |
| `df.loc[indices, "col2"]` | Get the values of `"col2"` at the `indices` |
| `df.loc[indices, "col2"].tolist()` | Get the values of `"col2"` at the `indices` and export them to a list |

:::{#exm-}
Filter the PSTHs of all responsive units in the time interval between `tmin` and `tmax`. Then, them by `"unit_id"` and `"brain_area"` and get the index of the maximum `"baselined_spike_count"`. Finally, use `.reset_index()` to create a new data frame `peaks` with columns `"unit_id"`, `"brain_area"` and `"max_idx"`.
:::
```{python}
tmin = 0.02
tmax = 0.1
mask = (psths_responsive.time > tmin) & (psths_responsive.time < tmax)
peaks = (
    psths_responsive[mask]
    .groupby(["unit_id", "brain_area"])
    .baselined_spike_count.idxmax()
)
peaks = peaks.reset_index()
peaks.columns = ["unit_id", "brain_area", "max_idx"]
peaks
```

:::{#exr-}
Use `.loc[]` to get the `"time"` of the PSTHs at the index stored in `peak.max_idx` and export them `.tolist()`. Store these values in a new column of `peaks` called `"latency"`.
:::
:::{.sol}
```{python}
peaks["latency"] = psths_responsive.loc[peaks.max_idx, "time"].tolist()
peaks
```
:::

:::{#exr-}
Create a `sns.kdeplot` with `common_norm=False` for the peak `"latency"` and add a `hue` to encode the `"brain_area"`. What new information does this graph reveal compared to the average PSTHs per brain area?
:::
:::{.sol}
```{python}
sns.kdeplot(peaks, x="latency", hue="brain_area", common_norm=False)
```
:::

:::{#exr-}
Change `tmin` and `tmax` to extract the time interval after the stimulus offset which happens at `0.25` seconds. Then, get the peak latencies for each unit and visualize the distribution of peak latency across areas in a `sns.kdeplot`.
:::
:::{.sol}
```{python}
tmin = 0.25
tmax = 0.35
mask = (psths_responsive.time > tmin) & (psths_responsive.time < tmax)
peaks = (
    psths_responsive[mask]
    .groupby(["unit_id", "brain_area"])
    .baselined_spike_count.idxmax()
)
peaks = peaks.reset_index()
peaks.columns = ["unit_id", "brain_area", "max_idx"]
peaks["latency"] = psths_responsive.loc[peaks.max_idx, "time"].tolist()
sns.kdeplot(peaks, x="latency", hue="brain_area", common_norm=False)
```
:::
