---
title: "Computing Neural Firing Rates"
engine: Jupyter
format: ipynb
filter:
    - assign
execute: 
  cache: true
number-sections: true
number-depth: 2
---

## Preparation

Import the modules required for this session
```{python}
import pandas as pd
import numpy as np
from matplotlib import pyplot as plt
from scipy.stats import wilcoxon
```

Define functions required for this session
```{python}
class utils:
    def find_spikes_in_window(spikes, stimuli, tmin, tmax):
        t = stimuli["start_time"].to_numpy()
        spike_time = spikes["spike_time"].to_numpy()
        spike_is_after_t = spike_time[:, np.newaxis] > t[np.newaxis, :] + tmin
        spike_is_before_tplus = spike_time[:, np.newaxis] < t[np.newaxis, :] + tmax
        spike_is_in_window = spike_is_after_t & spike_is_before_tplus
        mask = spike_is_in_window.any(axis=1)
        spikes_in_window = spikes[mask]
        return spikes_in_window.reset_index()
```

Download the data required for this session
```{python}
import os
import requests
import zipfile

url = "https://uni-bonn.sciebo.de/s/FV84Gvj3ZKHPN4Z"
fname = "allen"

if not os.path.exists("../data"):
    os.mkdir("../data")

if not os.path.exists(f"../data/{fname}"):
    response = requests.get(f"{url}/download")
    with open(f"{fname}.zip", "wb") as file:
        file.write(response.content)

    with zipfile.ZipFile(f"{fname}.zip", "r") as zip_ref:
        zip_ref.extractall(f"../data/{fname}")
        os.remove(f"{fname}.zip")
```


## Referencing Spike Times to Stimulus Presentations

| Code | Description |
| --- | --- |
| `df = pd.read_parquet("mydata.parquet")` | Read the file `"mydata.parquet"` into a data frame `df` |
| `utils.find_spikes_in_window(spikes, stimuli, tmin, tmax)` | Find the spikes that occurr between `tmin` and `tmax` with respect to the stimuli |
| `np.searchsorted(x, 5)` | Search the location in the sorted array `x` where you could insert the value `5` while keeping the sorting |

---

:::{#exr-}
Load the data stored in the the files `"../data/flash_spikes.parquet"` and `"../data/flash_stimuli.parquet"` and assign them to two variables called `spikes` and `stimuli`.
:::
:::{sol.}
```{python}
session = "ses-778240327"
spikes = pd.read_parquet(f"../data/allen/{session}/flash_spikes.parquet")
stimuli = pd.read_parquet(f"../data/allen/{session}/flash_stimuli.parquet")
```
:::

:::{#exr-}
Use the function `utils.find_spikes_in_window()` to find all spikes that happend between **-0.5 and 0.5 s** after stimulus onset. Overwrite the value of `spikes` with the returned data frame.
:::
:::{sol.}
```{python}
spikes = utils.find_spikes_in_window(spikes, stimuli, -0.5, 0.5)
```
:::

:::{#exm-}
Get the 20th stimulus onset time `t` and use `np.searchsorted` to find the index of the first spike after `t-0.5` and assign it to the variable `idx_start`. Then, get the spike at that index.
```{python}
t = stimuli.loc[20, "start_time"]
idx_start = np.searchsorted(spikes["spike_time"], t - 0.5)
spikes.loc[idx_start]
```
:::

:::{#exr-}
Use `np.searchsor` to get the first spike after `t+0.5` and assign it to the variable `idx_stop`. Subtract 1 from `idx_stop` to ensure the spike is contained within the interval from **-0.5 to 0.5 s** and get the spike at that index.
:::
:::{sol.}
```{python}
idx_stop = np.searchsorted(spikes["spike_time"], t + 0.5) - 1
spikes.loc[idx_stop]
```
:::

:::{#exm-}
Get all spikes between `idx_start` and `idx_stop` and subtract `t` to get the spike times relative to stimulus onset.
```{python}
spikes.loc[idx_start:idx_stop, "spike_time"] - t
```
:::

:::{#exr-}
The cell below uses `np.searchsorted` to find the location of the first spike **0.5 s before** stimulus onset for every stimulus. What is the length of `indices_start`?
```{python}
indices_start = np.searchsorted(spikes["spike_time"], stimuli["start_time"] - 0.5)
```
:::
:::{sol.}
```{python}
len(indices_start)
```
:::

:::{#exr-}
Use `np.searchsorted` to find the first spike **0.5 s after** stimulus onset for every stimulus and subtract 1 from the returned indices to get the last spike **before** 0.5 seconds have passed.
:::
:::{sol.}
```{python}
indices_stop = np.searchsorted(spikes["spike_time"], stimuli["start_time"] + 0.5) - 1
```
:::

:::{#exr-}
The `for` loop below goes trough all the indices and stimulus times. Complete the loop by subtracting the stimulus onset time `t` from every spike between `idx_start` and `idx_stop` to calculate the spike times relatve to stimulus onset.
```{python}
# | eval: false
for idx_start, idx_stop, t in zip(indices_start, indices_stop, stimuli["start_time"]):
    spikes.loc[idx_start:idx_stop, "spike_time"] =
```
:::
:::{sol.}
```{python}
# | eval: false
for idx_start, idx_stop, t in zip(indices_start, indices_stop, stimuli["start_time"]):
    spikes.loc[idx_start:idx_stop, "spike_time"] -= t
```
:::

:::{#exr-}
Get the minimum and maximum `"spike_time"` in `spikes`. They should be within the time interval between **-0.5 and 0.5 s**. w
:::
```{python}
print(spikes["spike_time"].min())
print(spikes["spike_time"].max())
```

## Binning Continuous Spikes into a Histogram

| Code | Description |
| --- | --- |
| `np.linspace(start, stop, n)` | Create a vector of `n` elements linearliy spaced between `start` and `stop` |
| `counts, bins = np.histogram(x, bins)` | Create a histogram of the data in `x` and return the edges of the `bins` and the `counts` of observations per bin |
| `plt.bar(x, height, width)` | Create a bar plot with bars at locations `x` with a given `heigt` and `width` |
| `plt.axvline(x, ymin, ymax)` | Draw a vertical line at `x` between `ymin` and `ymax` |


:::{#exm-}
Create linearly spaced `bins` between **-0.5 and 0.5 s** that are **10 ms** wide and print them.
:::
```{python}
bin_size = 0.010
tmin = -0.5
tmax = 0.5
n_bins = int((tmax - tmin) / bin_size)
bins = np.linspace(tmin, tmax, n_bins + 1)
bins
```

:::{#exr-}
Create linearly spaced `bins` between **-0.1 and 0.4 s** that are **10 ms** wide and print them.
:::
:::{sol.}
```{python}
bin_size = 0.010
tmin = -0.1
tmax = 0.4
n_bins = int((tmax - tmin) / bin_size)
bins = np.linspace(tmin, tmax, n_bins + 1)
bins
```
:::

:::{#exr-}
Create linearly spaced `bins` between **-0.2 and 0.5 s** that are **20 ms** wide and print them.
:::
:::{sol.}
```{python}
bin_size = 0.020
tmin = -0.2
tmax = 0.4
n_bins = int((tmax - tmin) / bin_size)
bins = np.linspace(tmin, tmax, n_bins + 1)
bins
```
:::

:::{#exm-}
Create a histogram for the `spike_time` from unit `951035143` and normalize the spike `counts` by the number of stimuli and bin size to get the peri-stimulus time histgram (PSTH).
:::
```{python}
spike_time = spikes[spikes["unit_id"] == 951035143]["spike_time"]
counts, bin_edges = np.histogram(spike_time, bins=bins)
psth = counts / (len(stimuli) * bin_size)
```

:::{#exm-}
Compute the `bin_centers` and visualize the PSTH as a bar plot where each bar is one bin. Add dashed vertial lines that mark the stimulus onset and offset
:::
```{python}
bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2
plt.bar(bin_centers, psth, width=bin_size)
plt.axvline(x=0, ymin=0, ymax=1, linestyle="--", color="black")
plt.axvline(x=0.25, ymin=0, ymax=1, linestyle="--", color="black")
plt.xlabel("Time [s]")
plt.ylabel("Firing Rate [Hz]")
```

:::{#exr-}
Plot the PSTH for unit `951031253`.
:::
:::{sol.}
```{python}
spike_time = spikes[spikes["unit_id"] == 951031253]["spike_time"]
counts, bin_edges = np.histogram(spike_time, bins=bins)
psth = counts / (len(stimuli) * bin_size)
bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2
plt.bar(bin_centers, psth, width=bin_size)
plt.axvline(x=0, ymin=0, ymax=1, linestyle="--", color="black")
plt.axvline(x=0.25, ymin=0, ymax=1, linestyle="--", color="black")
plt.xlabel("Time [s]")
plt.ylabel("Firing Rate [Hz]")
```
:::

:::{#exr-psth1}
Plot the PSTH for unit `951031253` again but reduce the `bin_size` to **5 ms**. Does this reveal any new information about the firing behavior of this neuron?
:::
:::{sol.}
```{python}
bin_size = 0.005
tmin = -0.2
tmax = 0.4
n_bins = int((tmax - tmin) / bin_size)
bins = np.linspace(tmin, tmax, n_bins + 1)

spike_time = spikes[spikes["unit_id"] == 951031253]["spike_time"]
counts, bin_edges = np.histogram(spike_time, bins=bins)
psth = counts / (len(stimuli) * bin_size)
bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2
plt.bar(bin_centers, psth, width=bin_size)
plt.axvline(x=0, ymin=0, ymax=1, linestyle="--", color="black")
plt.axvline(x=0.25, ymin=0, ymax=1, linestyle="--", color="black")
plt.xlabel("Time [s]")
plt.ylabel("Firing Rate [Hz]")
```
:::

:::{#exr-psth2}
Plot the PSTH for unit `951026700` between **-0.5 and 0.5 s** with a `bin_size` of **10 ms**. Does it look like the response of this unit is modulated by the stimulus?
:::
:::{sol.}
```{python}
bin_size = 0.010
tmin = -0.5
tmax = 0.5
n_bins = int((tmax - tmin) / bin_size)
bins = np.linspace(tmin, tmax, n_bins + 1)
spike_time = spikes[spikes["unit_id"] == 951026700]["spike_time"]
counts, bin_edges = np.histogram(spike_time, bins=bins)
psth = counts / (len(stimuli) * bin_size)
bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2
plt.bar(bin_centers, psth, width=bin_size)
plt.axvline(x=0, ymin=0, ymax=1, linestyle="--", color="black")
plt.axvline(x=0.25, ymin=0, ymax=1, linestyle="--", color="black")
plt.xlabel("Time [s]")
plt.ylabel("Firing Rate [Hz]")
```
:::

:::{#exr-}
Complete the `compute_psth` function below by comuting the value of `psth`.
```{python}
# | eval: false
def compute_psth(spike_time, tmin, tmax, bin_size):
    n_bins = int((tmax - tmin) / bin_size)
    bins = np.linspace(tmin, tmax, n_bins + 1)
    counts, bin_edges = np.histogram(spike_time, bins=bins)
    psth = # your code here
    bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2
    return psth, bin_centers
```
:::
:::{sol.}
```{python}
def compute_psth(spike_time, tmin, tmax, bin_size):
    n_bins = int((tmax - tmin) / bin_size)
    bins = np.linspace(tmin, tmax, n_bins + 1)
    counts, bin_edges = np.histogram(spike_time, bins=bins)
    psth = counts / (len(stimuli) * bin_size)
    bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2
    return psth, bin_centers
```
:::

:::{#exr-}
Complete the `plot_psth` function below by creating the `plt.bar` plot.
```{python}
def plot_psth(psth, bin_centers):
    bin_size = bin_centers[1] - bin_centers[0]
    plt.bar( # your code here
    plt.axvline(x=0, ymin=0, ymax=1, linestyle="--", color="black")
    plt.axvline(x=0.25, ymin=0, ymax=1, linestyle="--", color="black")
    plt.xlabel("Time [s]")
    plt.ylabel("Firing Rate [Hz]")
```
:::
:::{sol.}
```{python}
def plot_psth(psth, bin_centers):
    bin_size = bin_centers[1] - bin_centers[0]
    plt.bar(bin_centers, psth, width=bin_size)
    plt.axvline(x=0, ymin=0, ymax=1, linestyle="--", color="black")
    plt.axvline(x=0.25, ymin=0, ymax=1, linestyle="--", color="black")
    plt.xlabel("Time [s]")
    plt.ylabel("Firing Rate [Hz]")
```
:::

:::{#exr-}
Run the cell below to use the newly created functions `compute_psth` and `plot_psth` to plot the PSTH for unit `951035143` between **-0.5 and 0.5 s** with a `bin_size` of **10 ms**
```{python}
spike_time = spikes[spikes["unit_id"] == 951035143]["spike_time"]
psth, bin_centers = compute_psth(spike_time, tmin=-0.5, tmax=0.5, bin_size=0.01)
plot_psth(psth, bin_centers)
```
:::

## Applying a Baseline to the PSTH

:::{#exm-}
Compute the PSTH for unit `951026700` and calculate the average firing rate within the `baseline` period from **-0.5 to 0 s**.
```{python}
spike_time = spikes[spikes["unit_id"] == 951026700]["spike_time"]
psth, bin_centers = compute_psth(spike_time, tmin=-0.5, tmax=0.5, bin_size=0.01)

baseline = (-0.5, 0)
baseline_start = np.argmin(np.abs(bin_centers - baseline[0]))
baseline_stop = np.argmin(np.abs(bin_centers - baseline[1]))
baseline_mean = psth[baseline_start:baseline_stop].mean()
```
:::

:::{#exr-}
Plot the `psth` using the `plot_psth` function with and without subtracting the `baseline_mean`.
:::
:::{sol.}
```{python}
plot_psth(psth, bin_centers)
plt.figure()
psth -= baseline_mean
plot_psth(psth, bin_centers)
```
:::

:::{#exr-}
Compute and plot the PSTH for unit `951026700` between **-0.2 and 0.4 s** with a `bin_size` of **10 ms** and apply a baseline correction using the period from **-0.2 to 0 s**.
:::
:::{sol.}
```{python}
spike_time = spikes[spikes["unit_id"] == 951031253]["spike_time"]
psth, bin_centers = compute_psth(spike_time, tmin=-0.2, tmax=0.4, bin_size=0.01)

baseline = (-0.2, 0)
baseline_start = np.argmin(np.abs(bin_centers - baseline[0]))
baseline_stop = np.argmin(np.abs(bin_centers - baseline[1]))
baseline_mean = psth[baseline_start:baseline_stop].mean()

plot_psth(psth - baseline_mean, bin_centers)
```
:::


:::{#exr-}
Compute and plot the PSTH for unit `951026481` between **-0.3 and 0.5 s** and use the time interval between **-0.3 and -0.15 s** to compute the baseline. Plot the PSTH with and without baseline correction. Do you think this baseline interval was a good choice?
:::
:::{sol.}
```{python}
spike_time = spikes[spikes["unit_id"] == 951026481]["spike_time"]
psth, bin_centers = compute_psth(spike_time, tmin=-0.3, tmax=0.5, bin_size=0.01)

baseline = (-0.3, -0.15)
baseline_start = np.argmin(np.abs(bin_centers - baseline[0]))
baseline_stop = np.argmin(np.abs(bin_centers - baseline[1]))
baseline_mean = psth[baseline_start:baseline_stop].mean()

plot_psth(psth, bin_centers)
plt.figure()
plot_psth(psth - baseline_mean, bin_centers)
```
:::

## Computing PSTHs for Neural Populations

:::{#exm-}
Select the spike times from all units in the primary visual cortex `"V1"` and get the number of units recorded in that area.
```{python}
area = "V1"
spike_time = spikes[spikes["brain_area"] == area]["spike_time"]
n_units = len(spikes[spikes["brain_area"] == area]["unit_id"].unique())
```
:::

:::{#exr-}
Compute and plot the PSTH for primary visual cortex between **-0.5 and 0.5 s** with a `bin_size` of **5 ms** and use the period between **0.5 and 0 s** as a baseline period. Divide the PSTh by `n_units` to normalize for the number of units recorded in V1.
:::
:::{#sol.}
```{python}
psth, bin_centers = compute_psth(spike_time, tmin=-0.5, tmax=0.5, bin_size=0.005)

baseline = (-0.5, 0)
baseline_start = np.argmin(np.abs(bin_centers - baseline[0]))
baseline_stop = np.argmin(np.abs(bin_centers - baseline[1]))
baseline_mean = psth[baseline_start:baseline_stop].mean()

psth = (psth - baseline_mean) / n_units

plot_psth(psth, bin_centers)
```
:::

:::{#exr-}
Plot the same PSTH for the anterolateral visual cortex `"AL"` and the posteriomedial visual cortex `"PM"`. Compare the absolute firing rates between the areas. What could be a problem with computing the population activity with this approach?
:::
:::{sol.}
```{python}
area = "PM"
spike_time = spikes[spikes["brain_area"] == area]["spike_time"]
n_units = len(spikes[spikes["brain_area"] == area]["unit_id"].unique())

psth, bin_centers = compute_psth(spike_time, tmin=-0.5, tmax=0.5, bin_size=0.005)

baseline = (-0.5, 0)
baseline_start = np.argmin(np.abs(bin_centers - baseline[0]))
baseline_stop = np.argmin(np.abs(bin_centers - baseline[1]))
baseline_mean = psth[baseline_start:baseline_stop].mean()

psth = (psth - baseline_mean) / n_units

plot_psth(psth, bin_centers)
```
:::

## Identifying Neurons that Respond to the Stimulus

| Code | Description |
| --- | --- |
| `wilcoxon(x, y)` | Test the null hypothesis that `x` and `y` come from the same distribution|
| `wilcoxon(x, y, alternative="greater")` | Test the null hypothesis that `x` and `y` come from the same distribution against the null hypothesis that the mean of `x` is `"greater"` |
| `wilcoxon(x, y, alternative="less")` | Test the null hypothesis that `x` and `y` come from the same distribution against the null hypothesis that the mean of `x` is `"less"` |

---

:::{#exm-}
Compute the PSTH for unit `951026700` and perform a Wilcoxon signed rank-sum test to test whether the firing rate after the stimulus `x` is `"greater"` than the firing rate before the stimulus `y`.
```{python}
spike_time = spikes[spikes["unit_id"] == 951026700]["spike_time"]
psth, bin_centers = compute_psth(spike_time, tmin=-0.2, tmax=0.2, bin_size=0.01)
wilcoxon(x=psth[bin_centers > 0], y=psth[bin_centers < 0], alternative="greater")
```
:::

:::{#exr-}
Perform a Wilcoxon signed rank-sum test to test whether the firing rate of unit `951026700` after the stimulus is `"less"` than the firing rate before the stimulus.
:::
:::{sol.}
```{python}
wilcoxon(x=psth[bin_centers > 0], y=psth[bin_centers < 0], alternative="less")
```
:::

:::{#exr-}
Perform a Wilcoxon signed rank-sum test to test whether the firing rate of unit `951035143` after the stimulus is `"greater"` than the firing rate before the stimulus.
:::
:::{sol.}
```{python}
spike_time = spikes[spikes["unit_id"] == 951026700]["spike_time"]
psth, bin_centers = compute_psth(spike_time, tmin=-0.2, tmax=0.2, bin_size=0.01)
wilcoxon(x=psth[bin_centers > 0], y=psth[bin_centers < 0], alternative="greater")
```
:::

:::{#exr-}
Complete the `for` loop below which computes the PSTH for every unit in the posteriomedial visual cortex `"PM"` and adds them to the list of `psths` if the response after the stimulus is significantly higher than the response before the stimulus.
```{python}
#| eval: false
spikes_v1 = spikes[spikes["brain_area"] == "PM"]
psths = []
for unit_id in spikes_v1["unit_id"].unique():
    spike_time = spikes[spikes["unit_id"] == unit_id]["spike_time"]
    psth, bin_centers = compute_psth(spike_time, tmin=-0.25, tmax=0.25, bin_size=0.01)
    z, p = wilcoxon( # your code here )
    if p < 0.05:
        psths.append(psth)
```
:::
:::{sol.}
```{python}
spikes_v1 = spikes[spikes["brain_area"] == "PM"]
psths = []
for unit_id in spikes_v1["unit_id"].unique():
    spike_time = spikes[spikes["unit_id"] == unit_id]["spike_time"]
    psth, bin_centers = compute_psth(spike_time, tmin=-0.25, tmax=0.25, bin_size=0.01)
    z, p = wilcoxon(
        x=psth[bin_centers > 0], y=psth[bin_centers < 0], alternative="greater"
    )
    if p < 0.05:
        psths.append(psth)
psth = np.mean(psths, axis=0)
plot_psth(psth, bin_centers)
```
:::

