---
title: "Mining Statistical Patterns with SPADE"
engine: Jupyter
format: ipynb
filters:
    - assign
number-sections: true
number-depth: 2
---

## Preparation

Import the modules required for this notebook
```{python}
import numpy as np
from matplotlib import pyplot as plt
import quantities as pq
from elephant.spike_train_generation import compound_poisson_process, homogeneous_poisson_process
from elephant.spade import spade
from viziphant.patterns import plot_patterns

np.random.seed(100)
%matplotlib inline
```


Define the utility functions required for this notebook.
```{python}
class utils:
    def find_synchronous_spikes(spike_trains):
        """
        Find the synchronous spikes in a list of spike trains.
        Arguments:
            sts (List of SpikeTrain): list of spike train objects.
        Returns:
            (np.ndarray): 1-dimensional array of the synchronous spike times (times are repeated for each synchronous spikes)
            (np.ndarray): 1-dimensional array with the indices of the spike trains containing the synchronous spikes
        """
        all_spikes = np.concatenate([spike_train.times for spike_train in spike_trains])
        all_trains = np.concatenate(
            [[i] * len(spike_train.times) for i, spike_train in enumerate(spike_trains)]
        )
        times = []
        units = []
        for s in np.unique(all_spikes):
            idx = np.where(all_spikes == s)[0]
            if len(idx) > 1:
                times.append(all_spikes[idx])
                units.append(all_trains[idx])
        if len(times) > 0:
            times = np.concatenate(times)
            units = np.concatenate(units)
        else:
            times = np.array([])
            units = np.array([])
            print("Found no synchronous spikes")
        return times, units

```


## Simulating Synchronous Spiking

In this section, we are going to explore Spike Pattern Detection and Evaluation (SPADE) which is a method to find recurring patterns of synchronous firing in large numbers of neurons. We are going to explore SPADE and its parameters by simulating data using a compound Poisson process. This simulation defines a baseline Poisson process that fires randomly and then makes the baseline process trigger spikes in other neurons, causing synchronous events. In this section, we are going to explore how this simulation works.

| Code | Description |
| --- | --- |
| `sts = compound_poission_process(rate, amplitude_distribution, t_stop)` | Generate a list of spike trains from a compound poisson process with a given `rate` and `amplitude_distribution` that determines the probability of synchronous spikes. Each spike train starts at time 0 and goes to `t_stop` |
| `rasterplot(sts)` | Create a raster plot for a list of spike trains |
| `x,y = find_synchronous_spikes(spiketrains)` | Returns the times `x` and indices `y` of synchronous spikes in a list of `spiketrains` |
| `plt.eventplot(x)` | Plot the events in `x` |
| `plt.scatter(x,y, color="red")` | Plot the data `x`, `y` in a `"red"` scatterplot |

---

:::{#exm-}
Generate 6 spike trains (1 less then the length of the `amplitude_distribution`) with a firing rate of `5` Hz and a duration of `10` s from a `compound_poisson_process` where the probability of synchronous spikes in all 6 spike trains is `0.01` (1%). Print the length of the returned list of spike trains `sts`.
:::
```{python}
amplitude_distribution = [0, 0.99, 0, 0, 0, 0, 0.01]
sts = compound_poisson_process(
    rate=5 * pq.Hz, amplitude_distribution=amplitude_distribution, t_stop=10 * pq.s
)
len(sts)
```

:::{#exm-}
Find the time points `x` and the spike train indices `y` of spikes in the spike train list `sts` that occur synchronously in multiple trains. Then use `plt.eventplot` to create a rasterplot of the spike trains `sts` and mark the synchronous spikes `x`, `y` in red.
:::
```{python}
x, y = utils.find_synchronous_spikes(sts)
plt.eventplot([st.times for st in sts], color="black")
plt.scatter(x, y, color="red")
```


:::{#exr-}
Generate spike trains with a firing rate of `5` Hz and a duration of `10` s from a `compound_poisson_process` with the `amplitude_distribution` defined below. How many spike trains are generated by this simulation and what is the probability of synchronous spikes in all neurons?
:::
```{python}
amplitude_distribution = [0, 0.98, 0, 0, 0, 0, 0, 0, 0.02]
```
:::{.sol}
```{python}
sts = compound_poisson_process(
    rate=5 * pq.Hz, amplitude_distribution=amplitude_distribution, t_stop=10 * pq.s
)
len(sts)
```
:::
:::{.direction}
```{python}
#| echo: false
print('​')
```
:::


:::{#exr-}
Generate spike trains with a firing rate of `5` Hz and a duration of `10` s from a `compound_poisson_process` with the `amplitude_distribution` defined below. How many spike trains are generated by this simulation and what is the probability of synchronous spikes in 3 neurons?
:::
```{python}
amplitude_distribution = [0, 0.95, 0, 0.04, 0, 0.01]
```
:::{.sol}
```{python}
sts = compound_poisson_process(
    rate=5 * pq.Hz, amplitude_distribution=amplitude_distribution, t_stop=10 * pq.s
)
len(sts)
```
:::
:::{.direction}
```{python}
#| echo: false
print('​')
```
:::

:::{#exr-}
Find the time points `x` and the spike train indices `y` of spikes in the spike train list `sts` that occur synchronously in multiple trains. Then use `plt.eventplot` to create a rasterplot of the spike trains `sts` and mark the synchronous spikes `x`, `y` in red.
:::
:::{.sol}
```{python}
x, y = utils.find_synchronous_spikes(sts)
plt.eventplot([st.times for st in sts], color="black")
plt.scatter(x, y, color="red")
```
:::
:::{.direction}
```{python}
#| echo: false
print('​')
```
:::

:::{#exr-}
Generate 7 spike trains with a firing rate of `5` Hz and a duration of `10` s from a `compound_poisson_process` where the probability of synchronous spikes in all 7 spike trains is `0.1` (10%). Then, plot the spike trains and mark the synchronous spikes in red.
:::
:::{.sol}
```{python}
amplitude_distribution = [0, 0.9, 0, 0, 0, 0, 0, 0.1]
sts = compound_poisson_process(
    rate=5 * pq.Hz, amplitude_distribution=amplitude_distribution, t_stop=10 * pq.s
)
x, y = utils.find_synchronous_spikes(sts)
plt.eventplot([st.times for st in sts], color="black")
plt.scatter(x, y, color="red")
```
:::
:::{.direction}
```{python}
#| echo: false
print('​')
```
:::

:::{#exr-}
Generate 4 spike trains with a firing rate of `5` Hz and a duration of `10` s from a `compound_poisson_process` where the probability of synchronous spikes in 2 spike trains is `0.05` (5%) and the probability of a synchronous spike in 3 spike trains is `0.01` (1%). Then, plot the spike trains and mark the synchronous spikes in red
:::
:::{.sol}
```{python}
amplitude_distribution=[0, 0.94, 0.05, 0.01, 0]
sts = compound_poisson_process(
    rate=5 * pq.Hz, amplitude_distribution=amplitude_distribution, t_stop=10 * pq.s
)
print(len(sts))
```
:::
:::{.direction}
```{python}
#| echo: false
print('​')
```
:::


## Finding and Visualizing Patterns with Spade

Now we can apply SPADE to the simulated data. SPADE utilizes an algorithm called frequent itemset mining which is a data mining technique used to discover patterns in large datasets by identifying frequently occurring sets of items. Each pattern is assigned a signature that consist of two values: the number of items contained in that pattern and the number of occurrences of that pattern. In this section, we are going to apply SPADE to the simulated data and evaluate the patterns that it is detecting.

| Code | Description |
| --- | --- |
| `results = spade(sts, binsize, winlen)` |  Run `spade` on the spike trains `sts` with the given `binsize` and `winlen` |
| `results = spade(sts, binsize, winlen, min_occ=3)` |  Run `spade` on the spike trains `sts` but only consider patterns that occur at least `3` times |
| `results = spade(sts, binsize, winlen, min_neu=3)` |  Run `spade` on the spike trains `sts` but only consider patterns that contain at least `3` neurons |
| `patterns = results["patterns"]` | Get the detected `"patterns"` from the `results` |
| `len(patterns)` | Get the number of detected patterns |
| `sig = [p["signature"] for p in patterns]` | Get a list with the `"signature"` of every pattern |
| `np.stack(sig)` | Stack the list `sig` into a 2D numpy array |
| `idx = np.argmax(sig[:,0])` | Get the index where the first column of `sig` is maximal |
| `plot_pattern(sts, patterns[0])` | Plot the spiketrains `sts` and highlight the first pattern in `patterns` |

---

Run the code below to generate 10 spike trains with synchronous spikes from a `compound_poisson_process` and add 90 purely random spike trains from a `homogeneous_poisson_process`.
```{python}
rate = 3 * pq.Hz
t_stop = 15 * pq.s
sts = compound_poisson_process(
    rate=rate,
    amplitude_distribution=[0, 0.92, 0, 0, 0, 0, 0, 0, 0, 0, 0.08],
    t_stop=t_stop,
)
for i in range(90):
    sts.append(homogeneous_poisson_process(rate=rate, t_stop=t_stop))
f"Number of spike trains: {len(sts)}"
```


:::{#exm-}
Apply `spade()` to th simulated spike trains `sts` with `binsize=5*pq.ms` and `winlen=1` and get the detected `"patterns"`
:::
```{python}
results = spade(spiketrains=sts, binsize=5 * pq.ms, winlen=1)
patterns = results["patterns"]
patterns
```

:::{#exr-}
How many patterns were detected (i.e. what is the length of `patterns`)
:::
:::{.sol}
```{python}
len(patterns)
```
:::
:::{.direction}
```{python}
#| echo: false
print('​')
```
:::

:::{#exr-}
Use `plot_patterns` to plot the first pattern in `patterns`.
:::
:::{.sol}
```{python}
plot_patterns(sts, patterns[0])
```
:::

:::{#exm-stack}
Get the `"signature"` of every pattern `p` in `patterns` stack them into one numpy array. Then print the signatures. Each row represents one pattern. The first column indicates how many neurons are part of this pattern, the second column indicates how often this pattern occurs.
:::
```{python}
sig = np.stack([p["signature"] for p in patterns])
sig
```

:::{#exr-}
Use `np.argmax` on the second column of `sig` to find the pattern that occurred the most often. Get it from the list of `patterns` and print it
:::
:::{.sol}
```{python}
idx = np.argmax(sig[:,1])
patterns[idx]
```
:::
:::{.direction}
```{python}
#| echo: false
print('​')
```
:::

:::{#exr-}
Use `plot_patterns` to plot the pattern that occurred most often.
:::
:::{.sol}
```{python}
plot_patterns(sts, patterns[idx])
```
:::
:::{.direction}
```{python}
#| echo: false
print('​')
```
:::

:::{#exr-}
Use `np.argmax` on the first column of `sig` to find the pattern that contains the most neurons. Get it from the list of `patterns` and print it.
:::
:::{.sol}
```{python}
idx = np.argmax(sig[:, 0])
patterns[idx]
```
:::
:::{.direction}
```{python}
#| echo: false
print('​')
```
:::

:::{#exr-}
Use `plot_patterns` to plot the pattern that contains the most neurons.
:::
:::{.sol}
```{python}
plot_patterns(sts, patterns[idx])
```
:::
:::{.direction}
```{python}
#| echo: false
print('​')
```
:::

:::{#exr-}
Compute the product of both columns of `sig` and apply `np.argmax()` to the result to get the pattern where product of the patterns number of occurrences and number of neurons is maximal. Then, get that pattern from the list of `patterns` and print it. Which `"neurons"` are contained in this pattern?
:::
:::{.sol}
```{python}
idx = np.argmax(sig[:, 0] * sig[:, 1])
patterns[idx]
```
:::
:::{.direction}
```{python}
#| echo: false
print('​')
```
:::

:::{#exr-}
Use `plot_patterns` to plot that pattern.
:::
:::{.sol}
```{python}
plot_patterns(sts, patterns[idx])
```
:::
:::{.direction}
```{python}
#| echo: false
print('​')
```
:::

:::{#exr-}
Rerun `spade()` with `min_occ=3` and `min_neu=3` to only include patterns that occur at least `3` times and contain at least `3` neurons and return the detected `"patterns"`.
:::
:::{.sol}
```{python}
results = spade(spiketrains=sts, binsize=5 * pq.ms, winlen=1, min_occ=3, min_neu=3)
patterns = results["patterns"]
patterns
```
:::
:::{.direction}
```{python}
#| echo: false
print('​')
```
:::

:::{#exr-}
Get the `"signature"` of every pattern as shown in @exm-stack and print them.
:::
:::{.sol}
```{python}
sig = np.stack([p["signature"] for p in patterns])
sig
```
:::
:::{.direction}
```{python}
#| echo: false
print('​')
```
:::

:::{#exr-}
Find the pattern that occured most often and print it.
:::
:::{.sol}
```{python}
idx = np.argmax(sig[:, 1])
plot_patterns(sts, patterns[idx])
```
:::
:::{.direction}
```{python}
#| echo: false
print('​')
```
:::

## Statistical Inference with Surrogate Data

SPADE can not only find frequently occurring items, it can also test their statistical significance. This is done by generating surrogate data sets which are copies of the original data where the spike times are randomly dithered. By performing the frequent itemset mining on the surrogate data, the algorithm obtains a null-distribution of the patterns that ought to be expected from random data. We can then obtain the p-values for the actually observed patterns by checking how often a pattern with the given signature appears in the surrogate data. In this section, we will explore how to do statistical inference with SPADE and select patterns that are significant.

| Code | Description |
| --- | --- |
| `results = spade(sts, binsize, winlen, n_surr=100)` | Run `spade()` on the spike trains `sts` and generate `100` surrogate data sets for statistical inference |
| `pvalue_spectrum = results["pvalue_spectrum"]` | Get the spectrum of p-values computed on the surrogate data |
| `patterns = results["patterns"]` | Get the `"patterns"` detected by `spade()` |
| `[p for p in patterns if p["pvalue"] < 0.05]` | Get all patterns where the `"pvalue"` is below `0.05` |
| `results = spade(sts, binsize, winlen, psr_param=[0, 1, 0])` | Run `spade()` and perform a pattern set reduction that drops patterns that are contained in a larger superset |

---

:::{#exm-}
Apply `spade()` to the spike trains `sts` and test the significance of the detected `patterns` based on `10` surrogate data sets. Get the `"pvalue_spectrum"` from the results and print it. Each row contains a pattern signature and the associated p-value. For example `[2, 11, 0.1]` indicates that a pattern of `2` neurons that occurs `11` times has a p-value of `0.1`.
:::
```{python}
results = spade(spiketrains=sts, binsize=5 * pq.ms, winlen=1, n_surr=10)
pvalue_spectrum = results["pvalue_spectrum"]
pvalue_spectrum
```

:::{#exr-}
Run `spade()` with `binsize=5*pq.ms`, `winlen=1` and `n_surr=20`. Then, get the `"pvalue_spectrum"`. What is the p-value of a 2 neuron pattern that occurs 10 times?
:::
:::{.sol}
```{python}
results = spade(spiketrains=sts, binsize=5 * pq.ms, winlen=1, n_surr=20)
pvalue_spectrum = results["pvalue_spectrum"]
pvalue_spectrum
```
:::
:::{.direction}
```{python}
#| echo: false
print('​')
```
:::

:::{#exr-}
Run `spade()` with `binsize=5*pq.ms`, `winlen=1` and `n_surr=100`. Then, get the `"pvalue_spectrum"`. What is the p-value of a 2 neuron pattern that occurs 12 times?
:::
:::{.sol}
```{python}
results = spade(spiketrains=sts, binsize=5 * pq.ms, winlen=1, n_surr=100)
pvalue_spectrum = results["pvalue_spectrum"]
pvalue_spectrum
```
:::
:::{.direction}
```{python}
#| echo: false
print('​')
```
:::

:::{#exm-}
Get the `"patterns"` from the `results` and find all patterns with a `"pvalue"` below `0.05`.
:::
```{python}
patterns = results["patterns"]
significant_patterns = [p for p in patterns if p["pvalue"] < 0.05]
significant_patterns
```

:::{#exr-}
Plot all significant patterns (HINT: `plot_patterns` accepts multiple patterns).
:::
:::{.sol}
```{python}
plot_patterns(sts, significant_patterns)
```
:::
:::{.direction}
```{python}
#| echo: false
print('​')
```
:::

:::{#exr-}
Rerun `spade()` with `psr_param=[0,1,0]` to perform pattern set reduction where patterns that are subsets of a larger superset are discarded. Then get the `"patterns"` from the results of `spade()`.
:::
:::{.sol}
```{python}
results = spade(
    spiketrains=sts, binsize=5 * pq.ms, winlen=1, n_surr=50, psr_param=[0, 1, 0]
)
patterns = results["patterns"]
```
:::
:::{.direction}
```{python}
#| echo: false
print('​')
```
:::

:::{#exr-}
Get the `"patterns"` from the `results`, find all patterns with a `"pvalue"` below `0.05` and plot them.
:::
:::{.sol}
```{python}
patterns = results["patterns"]
significant_patterns = [p for p in patterns if p["pvalue"] < 0.05]
plot_patterns(sts, significant_patterns)
```
:::
:::{.direction}
```{python}
#| echo: false
print('​')
```
:::

:::{#exr-}
What are the p-values of the significant patterns?
:::
:::{.sol}
```{python}
[p["pvalue"] for p in significant_patterns]
```
:::
:::{.direction}
```{python}
#| echo: false
print('​')
```
:::
