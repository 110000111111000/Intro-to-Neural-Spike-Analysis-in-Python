---
title: "Estimating Receptive Field Maps"
engine: Jupyter
format: ipynb
filters:
    - assign
execute: 
  cache: true
number-sections: true
number-depth: 2
---

## Preparation

Import the modules required for this notebook
```{python}
from pathlib import Path
import numpy as np
import pandas as pd
from matplotlib import pyplot as plt
```

Define the functions required for this notebook
```{python}
class utils:
    def count_spikes_in_window(unit, tmin, tmax):
        spike_is_after_stim = unit["spike_time"] >= tmin
        spike_is_within_win = unit["spike_time"] < tmax
        spike_count = sum(spike_is_after_stim & spike_is_within_win)
        return spike_count
```

Download the data
```{python}
import os
import requests
import zipfile

url = "https://uni-bonn.sciebo.de/s/FV84Gvj3ZKHPN4Z"
fname = "allen"

if not os.path.exists("../data"):
    os.mkdir("../data")

if not os.path.exists(f"../data/{fname}"):
    response = requests.get(f"{url}/download")
    with open(f"{fname}.zip", "wb") as file:
        file.write(response.content)

    with zipfile.ZipFile(f"{fname}.zip", "r") as zip_ref:
        zip_ref.extractall(f"../data/{fname}")
        os.remove(f"{fname}.zip")
```

## Iterating Analyses with For Loops

## Comparing Responses to Different Stimuli

| Code | Description |
| --- | --- |
| `df = pd.read_parquet("mydata.parquet")` | Read the data stored in `"mydata.parquet"` and write it to the data frame `df` |
| `df2 = df.copy()` | Copy the data frame `df` and assign the copy to a new variable `df2` |
| `utils.count_spikes_in_window(spikes, tmin, tmax)` | Count the number of spikes in a `spikes` data frame that happen between `tmin` and `tmax` |
| `df.loc[3, "col1"]` | Get the value of the column `"col1"` at the index `3` |
| `df.loc[3, "col1"] = 1` | Set the value of the column `"col1"` at the index `3` to `1` |

---

:::{#exr-}
Load the data stored in `"../data/gabor_stimuli.parquet"` into data frames and assign it to a variable `stimuli`, then print the first 5 rows. Which columns describe the kind of stimulus that was presented in the given trial?
:::

:::{.sol}
```{python}
session = "ses-778240327"
stimuli = pd.read_parquet(f"../data/allen/{session}/gabor_stimuli.parquet")
stimuli.head(5)
```
:::

:::{#exr-}
Load the data stored in `"../data/gabor_spikes.parquet"` into a data frame and assign it to a variable `spikes`, then print the first 10 rows.
:::

:::{.sol}
```{python}
session = "ses-778240327"
spikes = pd.read_parquet(f"../data/allen/{session}/gabor_spikes.parquet")
spikes.head(10)
```
:::

:::{#exm-spike_count}
Count the number of spikes produces by unit `951035143` within 0.2 seconds after the presentation of the first stimulus and print the stimulus location and `spike_count`.
:::

```{python}
stim = stimuli.loc[0]
unit = spikes[spikes["unit_id"] == 951035143]
spike_count = utils.count_spikes_in_window(
    unit, stim["start_time"], stim["start_time"] + 0.2
)

print(
    f"stimulus at x={stim["x_position"]} and y={stim["y_position"]} elicited {spike_count} spikes"
)
```


:::{#exr-}
Count the number of spikes produces by unit `951035143` within 0.2 seconds after the presentation of the second stimulus using a `for` loop and print the stimulus location and `spike_count`.
:::
:::{.sol}
```{python}
stim = stimuli.loc[2]
unit = spikes[spikes["unit_id"] == 951035143]
spike_count = utils.count_spikes_in_window(
    unit, stim["start_time"], stim["start_time"] + 0.2
)

print(
    f"stimulus at x={stim["x_position"]} and y={stim["y_position"]} elicited {spike_count} spikes"
)
```
:::

:::{#exr-}
Count the number of spikes produces by unit `951035143` within 0.2 seconds after the presentation of the first stimulus using a `for` loop and print the stimulus location and `spike_count`.
:::
:::{.sol}
```{python}
for i in range(10):
    stim = stimuli.loc[i]
    unit = spikes[spikes["unit_id"] == 951035143]
    spike_count = utils.count_spikes_in_window(
        unit, stim["start_time"], stim["start_time"] + 0.2
    )

    print(
        f"stimulus at x={stim["x_position"]} and y={stim["y_position"]} elicited {spike_count} spikes"
    )
```
:::

:::{#exr-}
Count the number of spikes produces by the `units` defined below within 0.2 seconds after the presentation of the first stimulus using a `for` loop and print the stimulus location and `spike_count`.
:::
```{python}
units = [951035507, 951030824, 951021523]
```
:::{.sol}
```{python}
for unit_id in units:
    stim = stimuli.loc[0]
    unit = spikes[spikes["unit_id"] == unit_id]
    spike_count = utils.count_spikes_in_window(
        unit, stim["start_time"], stim["start_time"] + 0.2
    )
    print(unit_id)
    print(
        f"stimulus at x={stim["x_position"]} and y={stim["y_position"]} elicited {spike_count} spikes"
    )
```
:::

:::{#exr-}
The cell below selects all spikes produced by the `unit` number `951035143` then copies the `stimuli` and creates a new column in the `unit_stimuli` data frame called `"spike_count"`. Loop trough all stimuli, get the spike count within 0.2 seconds after each stimulus and write it in the `"spike_count"` column. Then, print the first 5 columns of `stimuli` to ensure the spike counts were stored correctly.
:::
```{python}
unit = spikes[spikes["unit_id"] == 951035143]
unit_stimuli = stimuli.copy()
unit_stimuli["spike_count"] = 0
```
:::{.sol}
```{python}
for i in range(len(stimuli)):
    stim = stimuli.loc[i]
    spike_count = utils.count_spikes_in_window(
        unit, stim["start_time"], stim["start_time"] + 0.2
    )
    unit_stimuli.loc[i, "spike_count"] = spike_count
unit_stimuli.head()
```
:::

:::{#exr-}
For the same unit, get the spike counts in the 200 ms before each stimulus
:::
:::{.sol}
```{python}
for i in range(len(stimuli)):
    stim = stimuli.loc[i]
    spike_count = utils.count_spikes_in_window(
        unit, stim["start_time"]-0.2, stim["start_time"]
    )
    unit_stimuli.loc[i, "spike_count"] = spike_count
unit_stimuli.head()
```
:::

:::{#exr-}
Complete the `count_spikes_per_stimulus` function below by computing the `spike_count` for each stimulus and writing it into the `unit_stimuli` data frame.
:::
```{python}
# | eval: false
def count_spikes_per_stimulus(unit_id, stimuli, tmin, tmax):
    unit = spikes[spikes["unit_id"]==unit_id]
    unit_stimuli = stimuli.copy()
    unit_stimuli["spike_count"] = 0
    for i in range(len(stimuli)):
        stim = stimuli.loc[i]
        spike_count = # your code here
        unit_stimuli.loc[i, "spike_count"] = # your code here
    return unit_stimuli
```
:::{.sol}
```{python}
def count_spikes_per_stimulus(unit_id, stimuli, tmin, tmax):
    unit = spikes[spikes["unit_id"]==unit_id]
    unit_stimuli = stimuli.copy()
    unit_stimuli["spike_count"] = 0
    for i in range(len(stimuli)):
        stim = stimuli.loc[i]
        spike_count = utils.count_spikes_in_window(
            unit, stim["start_time"] + tmin, stim["start_time"] + tmax
        )
        unit_stimuli.loc[i, "spike_count"] = spike_count
    return unit_stimuli
```
:::

:::{#exr-}
Use the `count_spikes_per_stimulus()` function to count the spikes produced by unit `951035143` in the 0.2 before each stimulus onset (i.e. the baseline).
:::
:::{.sol}
```{python}
count_spikes_per_stimulus(951035143, stimuli, -0.2, 0)
```
:::

## Creating a Map

| Code | Description |
| --- | --- |
| `x = df["col1"].unique()` | Get the unique values in the column `"col1"` and assign them to the variable `x` |
| `x.sort()` | Sort the array `x` |
| `df = pd.DataFrame(1, index=y, columns=x)` | Create a new `DataFrame` where the `index` values are `y`, the column names are `x` and all values are `1` |
| `df.groupby("col1").mean()` | Group the data frame `df` by the column `"col1"` and calculate the `.mean()` for every unique value of `"col1"` |
| `df.groupby(["col1", "col2"]).mean()` | Group the data frame `df` by the columns `"col1"` and `"col2"` and calculate the `.mean()` for every unique combination of `"col1"` and `"col2"` |

---

:::{#exm-}
Get all of the unique `"x_positions"` in `unit_stimuli` and sort them.
:::
```{python}
x_locs = stimuli["x_position"].unique()
x_locs.sort()
```

:::{#exr-}
Get all of the unique `"y_positions"` in `unit_stimuli` and sort them.
:::
:::{.sol}
```{python}
y_locs = stimuli["y_position"].unique()
y_locs.sort()
```
:::

:::{#exr-rf}
Create a new `DataFrame` to store the data for the receptive field. This `DataFrame` should have the y-locations as `index`, the x-locations as `columns` and `0.0` for all values. Assign this `DataFrame` to a variable called `rf` and print it.
:::
:::{.sol}
```{python}
rf = pd.DataFrame(0.0, index=y_locs, columns=x_locs)
rf
```
:::

:::{#exm-}
Compute the mean `"spike_count"` for every `"x_position"` in `unit_stimuli` and print it.
:::
```{python}
avg_counts_per_x = unit_stimuli.groupby(["x_position"])["spike_count"].mean()
avg_counts_per_x
```

:::{#exr-}
Compute the mean `"spike_count"` for every `"y_position"` in `unit_stimuli` and print it.
:::
:::{.sol}
```{python}
avg_counts_per_y = unit_stimuli.groupby(["y_position"])["spike_count"].mean()
avg_counts_per_y
```
:::

:::{#exr-mean_count}
Compute the mean `"spike_count"` for every `"x_position"` and every `"y_position"` in `unit_stimuli` and assign it to a variable `avg_counts_per_loc`, then print it.
:::
:::{.sol}
```{python}
avg_counts_per_loc = unit_stimuli.groupby(["y_position", "x_position"])[
    "spike_count"
].mean()
avg_counts_per_loc
```
:::

:::{#exm-}
Use a `for` loop to iterate the `.index` of the `avg_counts_per_loc` computed in @exr-mean_count and print each index.
:::
```{python}
for x, y in avg_counts_per_loc.index:
    print(x, y)
```

:::{#exr-}
Use a `for` loop to iterate the `.index` of the `avg_counts_per_loc`, get the average spike count at every location and print it.
:::
:::{.sol}
```{python}
for x, y in avg_counts_per_loc.index:
    print(x, y, avg_counts_per_loc.loc[y, x])
```
:::

:::{#exr-}
Use a `for` loop to iterate the `.index` of the `avg_counts_per_loc`, get the average spike count at every location and store it in the data frame `rf` generated in @exr-rf.
:::
:::{.sol}
```{python}
for x, y in avg_counts_per_loc.index:
    rf.loc[y, x] = avg_counts_per_loc.loc[y,x]
```
:::

:::{#exm-}
Run the cell below to plot the receptive field `rf` as an image.
:::
```{python}
plt.imshow(df)
```

:::{#exr-}
Complete the `create_receptive_field_map()` function below by writing the avgerage spike count per location into the data frame `rf`.
```{python}
def create_receptive_field_map(unit_stimuli):
    avg_counts_per_loc = unit_stimuli.groupby(["y_position", "x_position"])[
        "spike_count"
    ].mean()
    x_locs = stimuli["x_position"].unique()
    x_locs.sort()
    y_locs = stimuli["y_position"].unique()
    y_locs.sort()
    rf = pd.DataFrame(0.0, index=y_locs, columns=x_locs)
    for x, y in avg_counts_per_loc.index:
        rf.loc[y, x] = # your code here
    return rf
```
:::
:::{.sol}
```{python}
def create_receptive_field_map(unit_stimuli):
    avg_counts_per_loc = unit_stimuli.groupby(["y_position", "x_position"])[
        "spike_count"
    ].mean()
    x_locs = stimuli["x_position"].unique()
    x_locs.sort()
    y_locs = stimuli["y_position"].unique()
    y_locs.sort()
    rf = pd.DataFrame(0.0, index=y_locs, columns=x_locs)
    for (y, x), avg_count in avg_counts_per_loc.items():
        rf.loc[y, x] = avg_count
    return rf
```
:::

:::{#exm-}
Use the `count_spikes_per_stimulus()` function to count the spikes produced by unit `951035143` in the `0.2` seconds after every stimulus. Then use the `create_receptive_field_map()` function to compute the receptive field from the `unit_stimuli` and plot it as an image
:::
```{python}
unit_stimuli = count_spikes_per_stimulus(951035143, stimuli, tmin=0, tmax=0.2)
rf = create_receptive_field_map(unit_stimuli)
plt.imshow(rf)
```

:::{#exr-}
Compute and plot the receptive fields for units `951026579` and `951035458`. Which of those units has a clearly visible receptive field?
:::
```{python}
for unit_id in [951026579, 951035458]:
    unit_stimuli = count_spikes_per_stimulus(unit_id, stimuli, 0, 0.2)
    rf = create_receptive_field_map(unit_stimuli)
    plt.figure()
    plt.imshow(rf)
```

## Styling a Receptive Field Plot

| Code | Description |
| --- | --- |
| `im = plt.imshow(x)` | Plot the matrix `x` as an image and assign the returned object to the variable `im` |
| `cbar = plt.colorbar(im)` | Add a colobar to the image `im` and assign the returned object to the variable `cbar` |
| `cbar.set_label("color")` | Add the label `"color"` to the colorbar |
| `plt.imshow(x, interpolation="quadratic")` | Plot the matrix `x` as an image with `"quadratic"` interpolation |
| `plt.imshow(x, cmap="magma")` | Plot the matrix `x` as an image with the `"magma"` colormap |
| `plt.yticks(ticks, labels)` | Set the axis ticks labels at the y axis to `ticks` an label them with `labels` |
| `plt.gca().tick_params(axis="y", rotation=45)` | Rotate the axis tick labels on the `"y"` axis by 45 degree |
| `plt.grid(True)` | Add a grid to the current plot |

---

:::{#exm-}
Compute the receptive field for unit `951035143` and plot it with `"nearest"` interpolation
:::
```{python}
unit_stimuli = count_spikes_per_stimulus(951035143, stimuli, tmin=0, tmax=0.2)
rf = create_receptive_field_map(unit_stimuli)
plt.imshow(rf, interpolation="nearest")
```

:::{#exr-}
Plot the same receptive field with `"bilinear"`, `"bicubic"` and `"spline16"` interpolation. Which interpolation methods produced the best result?
:::
:::{.sol}
```{python}
for interpolation in ["bilinear", "bicubic", "spline16"]:
    plt.figure()
    plt.imshow(rf, interpolation=interpolation)
```
:::

:::{#exr-}
Plot the receptive field map using an interpolation method of your choice with the `"plasma"` colormap.
:::
:::{.sol}
```{python}
plt.imshow(rf, interpolation="spline16", cmap="plasma")
```
:::

:::{#exr-}
Check the [matplotlib documentation](https://matplotlib.org/stable/users/explain/colors/colormaps.html) for available colormaps and plot the receptive field with two different color maps. Choose one that is a good fit for this plot and one that is bad.
:::
:::{.sol}
```{python}
plt.imshow(rf, interpolation="spline16", cmap="inferno")
plt.figure()
plt.imshow(rf, interpolation="spline16", cmap="jet")
```
:::

:::{#exm-}
Add a `colorbar` to the receptive field.
:::
```{python}
im = plt.imshow(rf, interpolation="spline16", cmap="inferno")
cbar = plt.colorbar(im)
```

:::{#exr-}
Label the colorbar with `"Average Spike Count"`.
:::
:::{.sol}
```{python}
im = plt.imshow(rf, interpolation="spline16", cmap="plasma")
cbar = plt.colorbar(im)
cbar.set_label("Average Spike Count")
```
:::

:::{#exm-}
Use the x-positions of the stimuli stored in `rf.colums` as tick labels for the x-axis and add an axis label to the x-axis.
:::
```{python}
im = plt.imshow(rf, interpolation="spline16", cmap="plasma")
plt.xticks(range(9), labels=rf.columns)
plt.xlabel("X location [degree]")
```

:::{#exr-}
Use the y-positions stored in `rf.index` as tick labels for the y-axis and add an axis label to the y-axis.
:::
:::{.sol}
```{python}
im = plt.imshow(rf, interpolation="spline16", cmap="plasma")
plt.xticks(range(9), labels=rf.columns)
plt.xlabel("X location [degree]")
plt.yticks(range(9), labels=rf.index)
plt.ylabel("Y location [degree]")
```
:::

:::{#exm-}
Rotate the `"x"` axis tick labels by `45` degree.
:::
```{python}
im = plt.imshow(rf, interpolation="spline16", cmap="plasma")
plt.xticks(range(9), labels=rf.columns)
plt.xlabel("X location [degree]")
plt.gca().tick_params(axis="x", rotation=45)
```

:::{#exr-}
Rotate both axis tick labels by `45` degree.
:::
:::{.sol}
```{python}
im = plt.imshow(rf, interpolation="spline16", cmap="plasma")
plt.xticks(range(9), labels=rf.columns)
plt.xlabel("X location [degree]")
plt.yticks(range(9), labels=rf.index)
plt.ylabel("Y location [degree]")
plt.gca().tick_params(axis="both", rotation=45)
```
:::

:::{#exm-}
Add a `grid()` to the plot
:::
```{python}
im = plt.imshow(rf, interpolation="spline16", cmap="plasma")
plt.grid(True)
```

:::{#exr-}
Make the grid less obstructive by changing the linestyle (e.g. `linestyle=":"` or `linestyle="--"`) and opacity (e.g. `alpha=0.5`) of the grid.
:::
:::{.sol}
```{python}
im = plt.imshow(rf, interpolation="spline16", cmap="plasma")
plt.xticks(range(9), labels=rf.columns)
plt.xlabel("X location [degree]")
plt.yticks(range(9), labels=rf.index)
plt.ylabel("Y location [degree]")
plt.gca().tick_params(axis="both", rotation=45)
plt.grid(True, linestyle=":", alpha=0.8)
cbar = plt.colorbar(im)
cbar.set_label("Average Spike Count")
```
:::
